import { IssueType } from "@/types/types";

export const IssuesToucheese: IssueType[] = [
  {
    title: "React 렌더링 사이클 기반 비동기 상태 깜빡임 문제 최적화",
    imgBefore: "/img/toucheese-issue-01.webp",
    imgAfter: "/img/toucheese-issue-02.webp",
    objective: [
      "❶ sessionStorage 를 활용하여 본인인증 전후에도 데이터 유지",
      "❷ 회원가입 페이지 이동 후  sessionStorage 에서 불러와 기본값 설정",
      "❸ 본인인증 후 다시  input  입력 페이지로 리다이렉트 되었을 때 사용자 입력값 계속 유지 및 다음 버튼 활성화",
    ],
    problem: [
      "본인인증 후 리다이렉트 시  params 의  success 값을 읽어와 다음 이동 버튼 활성화 되는 과정에서 이름 및 휴대폰 번호  input 의  defaultValues로 적용된 sessionStorage 값이 렌더링 되었다가 휘발됨",
    ],
    analysis: [
      {
        issue: "react-hook-form reset 설정",
        subDetails: [
          "react-hook-form 의 상태를 수동으로 갱신해주는데 만약  reset 을 사용하지 않으면, 외부 데이터가 업데이트 되더라도 폼 값은 그대로 유지가 되는 문제가 발생한다는것을 파악하여 변경하였지만 문제는 해결되지 않음",
        ],
      },
      {
        issue: "리액트 공식 문서를 참고하여 시각적 깜빡임 원인 분석",
        subDetails: [
          "리액트의 순수 함수를 유지하기 위해 부수 효과를 다루는  useEffect 는  render ,  paint  과정 이후에 비동기적으로 실행되어 시각적 깜빡임이 생길 수 밖에 없음 확인",
        ],
      },
    ],
    solution:
      "초기 렌더링 시 상태 업데이트 지연으로 인해 UI가 비정상적으로 표시되는 문제를 확인하고  React  렌더링 사이클을 고려하여 DOM 렌더링 전에 상태를 동기적으로 갱신하여 초기화 흐름 개선",
    outcome: [
      "사용자가 오류로 인식할 수 있는 불편한 시각적 깜빡임을 개선하여 사용자 경험 향상",
      "불필요한 재입력 과정이 줄어 이탈률 감소 및 사용자 경험(UX) 향상",
      "useLayoutEffect 를 활용하여 렌더링 전에  sessionStorage  값을 불러와 적용 → 입력값이 비어있는 오류 방지",
    ],
  },
  {
    title: "이미지 최적화를 통한 네트워크 비용 절감",
    imgBefore: "/img/toucheese-issue-06.webp",
    imgAfter: "/img/toucheese-issue-03.webp",
    objective: [
      "❶ 스튜디오 중개 서비스 특성상 대량의 이미지가 한 번에 로드되는 구조 개선",
      "❷ 이미지 전환 없이 동일한 화면에서 썸네일 이미지들이 대량 출력됨에 따른 초기 로딩 시간 최소화",
      "❸ 이미지 용량 최적화를 통해 사용자 네트워크 부담 및 서버 트래픽 감소",
    ],
    problem: [
      "초기 접속 시 수십 장 이상의 고해상도 이미지가 동시에 출력되어 네트워크 비용이 증가하고, 페이지 로딩 시간이 지연되는 문제가 발생함",
      "일반 JPEG 포맷 사용으로 인해 이미지 용량이 크고, 모바일 환경에서 렌더링 성능 저하로 사용자 이탈 위험 존재",
      "로컬 환경 기준 Lighthouse 분석 결과 FCP 14.1초, LCP 26.7초로 매우 느린 응답 확인",
    ],
    analysis: [
      {
        issue: "기존 JPEG 이미지 사용에 따른 성능 저하",
        subDetails: [
          "이미지 한 장당 수백 KB에 달하는 용량이 누적되며, 비최적화 포맷 사용으로 용량 과다 및 해상도 대비 비효율적인 이미지 처리 발생",
          "이미지 포맷 변경 없이 해상도만 낮추면 화질 열화로 인해 사용자 경험이 저하되는 문제 발생",
        ],
      },
      {
        issue: "WebP 포맷의 용량 대비 품질 효율 분석",
        subDetails: [
          "같은 화질 기준으로 JPEG 대비 평균 25~35% 정도 용량 절감 가능",
          "모던 브라우저에서 WebP 포맷 지원이 안정화되었으며, fallback 처리 시 호환성 문제 없음",
        ],
      },
    ],
    solution:
      "브라우저의 WebP 지원 여부를 감지하는 유틸 함수를 구현하고, 지원하는 경우에는 WebP 포맷 이미지를 우선 로드하도록 로직 수정. 이미지 데이터 구성 시 포맷별 경로를 분리하여 상황에 맞게 자동 선택하도록 처리",
    outcome: [
      "로컬 기준 FCP 14.1초 → 3.6초, LCP 26.7초 → 9.3초로 개선 (FCP 기준 약 75%, LCP 기준 약 65%의 성능 개선)",
      "전체 이미지 트래픽 약 40% 절감 → 사용자 네트워크 환경에서의 데이터 소비 감소",
      "기존 이미지 대비 화질 손실 없이 성능 개선이 가능하여 사용자 UX 향상",
    ],
  },
  {
    title: "테스트 코드 기반의 입력 검증 로직 최적화",
    imgAfter: "/img/toucheese-issue-05.webp",
    objective: [
      "❶ 사용자 입력 검증 로직의 성능 측정 및 테스트 자동화",
      "❷ 반복 입력 환경에서 성능 저하가 발생하는 조건 식별 및 개선",
    ],
    problem: [
      "비밀번호 유효성 검사 로직에서 입력 길이에 관계없이 매번 정규식을 실행하고 있어 일부 입력에서는 과도한 연산 발생",
      "입력 초반과 같은 짧은 문자열에도 복잡한 정규식이 적용되며 전체 입력 흐름에서 미세한 성능 병목 발생",
    ],
    analysis: [
      {
        issue: "정규식과 조건문 실행 순서에 따른 처리 시간 차이",
        subDetails: [
          "`performance.now()` 기반 성능 측정 도구를 테스트 코드로 구현하여 평균 실행 시간 비교",
          "`validatePasswordWithLengthCheck` (길이 → 정규식) vs `validatePasswordRegexFirst` (정규식 → 길이) 비교",
          "길이 검사를 선행한 로직의 평균 실행 시간: 0.82ms",
          "정규식을 먼저 실행한 로직의 평균 실행 시간: 0.34ms → 더 빠름",
        ],
      },
      {
        issue: "실제 입력 시나리오에서의 의미 있는 순서 판단",
        subDetails: [
          "단순 길이 조건문은 빠르게 종료되지만 실행 흐름 상 조건 분기의 오버헤드가 누적되면 전체 성능에 영향",
          "정규식의 처리 비용이 낮고 조건 분기가 오히려 비용이 되는 경우 정규식 선 실행이 유리할 수 있음",
        ],
      },
    ],
    solution:
      "실제 테스트 결과에 따라 조건 분기 로직을 단순화하고 정규식을 먼저 실행한 뒤 길이 조건을 보완적으로 처리하는 방식으로 리팩토링",
    outcome: [
      "평균 실행 시간 0.82ms → 0.34ms로 약 58% 성능 개선",
      "입력 조건 순서 최적화로 미세한 성능 병목 제거",
      "테스트 코드 기반의 정량적 근거를 바탕으로 리팩토링 진행 → 코드 품질 및 유지보수성 향상",
    ],
  },
];

export const IssuesTrifly: IssueType[] = [
  {
    title:
      "항공기 좌석 데이터 기반 동적 그리드 UI 렌더링 및 복도 시각화 최적화",
    imgBefore: "/img/trifly-issue-01.webp",
    imgAfter: "/img/trifly-issue-02.webp",
    objective: [
      "❶ 다양한 항공기의 좌석 데이터를 기반으로 좌석 배치 및 복도 UI를 정확히 반영",
      "❷ 예매 가능/불가 상태를 시각적으로 구분할 수 있는 명확한 스타일 처리",
      "❸ 좌석 좌표 기반으로 항공기별 구조에 맞는 동적 그리드 렌더링",
    ],
    problem: [
      "정적 렌더링 방식으로 인해 첫 번째 줄의 좌석 정보만 반복 출력됨",
      "좌석 사이 복도(빈 공간)가 UI에 표시되지 않아 실제 구조와 불일치",
      "항공기의 좌석 정보가 항공사/기종마다 구조가 다르지만 37×10의 고정된 크기로 렌더링되어 실제 좌석 배치와 불일치",
    ],
    analysis: [
      {
        issue: "좌석 반복 렌더링 로직 문제",
        subDetails: [
          "모든 좌석을 반복하지 않고 첫 번째 줄의 좌석 배열만 기준으로 렌더링하여 전체 구조를 반영하지 못함",
          "좌석마다 다른 x, y 좌표를 기반으로 UI에 반영되어야 하지만 고정된 인덱스로만 접근",
        ],
      },
      {
        issue: "복도의 좌표 처리 미흡",
        subDetails: [
          "데이터 상에서 좌석이 없는 좌표를 고려하지 않아 복도가 표시되지 않음",
          "빈 공간에 대한 예외 처리가 없어 좌석과 복도의 구분이 되지 않음",
        ],
      },
      {
        issue: "항공기별 가변 좌석 구조에 대응하지 못하는 고정 그리드",
        subDetails: [
          "항공기의 좌석 정보는 항공사, 기종, 클래스 등에 따라 구조가 매우 다양하고 방대함",
          "하지만 기존 구현에서는 37×10의 고정 크기 배열로 렌더링되어 다양한 레이아웃에 유연하게 대응하지 못함",
          "이로 인해 실제 좌석 배열과 UI 간에 불일치가 발생하고 사용자 경험이 저하됨",
        ],
      },
    ],
    solution: [
      "좌석의 좌표(x, y)를 기반으로 그리드의 가로/세로 크기를 동적으로 생성하고 해당 좌표에 좌석 객체를 배치하여 정확한 구조를 반영",
      "좌석이 없는 좌표(null)는 복도로 인식하고 시각적으로 구분되도록 처리.",
      "travelerPricing.seatAvailabilityStatus 를 활용해 예매 가능 여부를 스타일로 구분하고, 다양한 기종의 방대한 좌석 구조에도 유연하게 대응할 수 있도록 확장성 확보",
    ],
    outcome: [
      "항공기 구조에 맞는 실제 좌석 배치도 렌더링이 가능해져 사용자 혼란 최소화",
      "좌석의 예매 가능 여부가 명확하게 구분되어 상호작용 향상",
      "고정된 그리드가 아닌 동적 구조로 다양한 항공기 레이아웃에 대응 가능",
      "복도가 시각적으로 명확히 표시되어 사용자의 공간 인지 향상",
    ],
  },
  {
    title:
      "Next.js App Router 구조적 제약 극복을 통한 페이지네이션 상태 동기화 및 UX 향상",
    imgAfter: "/img/trifly-issue-03.webp",
    objective: [
      "❶ 페이지네이션 클릭 시 URL query(page)를 기반으로 데이터 정확히 로드",
      "❷ 모바일에서는 무한스크롤, 데스크탑에서는 페이지네이션 UI를 제공하는 하이브리드 렌더링 처리",
    ],
    problem: [
      "Pagination.tsx에서 버튼 클릭 시 query 파라미터를 변경했지만, ReservationList.tsx에서 page 값을 인식하지 못해 항상 1페이지의 데이터만 렌더링됨",
      "Next.js App Router 구조상 searchParams는 페이지 컴포넌트에서만 사용 가능하여, 하위 컴포넌트에서는 URL 정보를 직접 사용할 수 없음",
    ],
    analysis: [
      {
        issue: "Next.js App Router의 구조적 제한",
        subDetails: [
          "App Router 환경에서 `searchParams`는 `page.tsx` 같은 최상위 서버 컴포넌트에서만 접근 가능",
          "ReservationList.tsx에서 직접 쿼리값을 읽으려 했지만 불가능 → 상태 불일치 발생",
        ],
      },
      {
        issue: "컴포넌트 간 상태 공유 실패",
        subDetails: [
          "page.tsx에서 받은 쿼리 값을 명시적으로 하위 컴포넌트에 전달하지 않으면 Pagination.tsx와 ReservationList.tsx 사이의 상태가 분리되어 UX 오류 발생",
        ],
      },
    ],
    solution: [
      "Next.js 구조상 `searchParams`는 페이지 단에서만 접근 가능한 제약을 명확히 이해하고 페이지 컴포넌트인 `page.tsx`에서 쿼리 파라미터를 파싱 후 `page` 값을 명시적으로 props로 전달하는 방식으로 리팩토링",
      "각 하위 컴포넌트는 단일 책임 원칙에 따라 `page` 상태만 사용하며 라우터에 의존하지 않도록 구조 정리",
      "이를 통해 App Router 환경에서의 페이지 상태 동기화 및 재사용 가능한 컴포넌트 설계를 구현",
    ],
    outcome: [
      "페이지네이션 동작 오류 해결 및 각 페이지별 정확한 데이터 렌더링 구현",
      "Next.js 구조에 대한 이해를 기반으로 예측 가능한 컴포넌트 트리 설계",
      "URL 기반 상태 동기화를 통해 검색 가능성과 사용자 경험(UX) 향상",
      "컴포넌트 간 책임 분리 및 명확한 상태 전달 방식 수립",
    ],
  },
];
